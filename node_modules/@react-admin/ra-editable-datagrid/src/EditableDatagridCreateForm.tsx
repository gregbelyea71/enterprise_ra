import React, {
    cloneElement,
    useCallback,
    ReactElement,
    ReactNode,
    useMemo,
} from 'react';

import PropTypes from 'prop-types';
import {
    useCreate,
    useNotify,
    useRefresh,
    useDatagridStyles,
    CRUD_CREATE,
    Record,
    useSaveModifiers,
    SaveContextProvider,
    useResourceContext,
} from 'react-admin';
import { Route, useHistory } from 'react-router-dom';
import { CreateRowContext } from './CreateRowContext';

const EditableDatagridCreateForm = (props: EditableDatagridCreateFormProps) => {
    const {
        basePath,
        classes,
        expand,
        hasBulkActions,
        createForm,
        hasStandaloneCreateForm,
        isStandaloneCreateFormVisible,
        closeStandaloneCreateForm,
    } = props;

    const history = useHistory();
    const notify = useNotify();
    const refresh = useRefresh();
    const resource = useResourceContext(props);
    const [create, { loading: saving }] = useCreate(resource, {});
    const hideCreateForm = useCallback((): void => {
        if (hasStandaloneCreateForm) {
            closeStandaloneCreateForm();
        } else {
            history.push(basePath);
        }
    }, [basePath, closeStandaloneCreateForm, hasStandaloneCreateForm, history]);

    const defaultOnSuccess = useCallback(() => {
        notify('ra.notification.created', 'info', {
            smart_count: 1,
        });
        refresh();
        hideCreateForm();
    }, [hideCreateForm, notify, refresh]);

    const defaultOnFailure = useCallback(
        error => {
            notify(
                typeof error === 'string'
                    ? error
                    : error.message || 'ra.notification.http_error',
                'warning'
            );
        },
        [notify]
    );

    const {
        onSuccessRef,
        setOnSuccess,
        onFailureRef,
        setOnFailure,
        transformRef,
        setTransform,
    } = useSaveModifiers({
        onFailure: defaultOnFailure,
        onSuccess: defaultOnSuccess,
    });

    const save = useCallback(
        (
            data: Partial<Record>,
            _, // unused redirectTo
            {
                onSuccess: onSuccessFromSave,
                onFailure: onFailureFromSave,
                transform: transformFromSave,
            } = {}
        ) =>
            Promise.resolve(
                transformFromSave
                    ? transformFromSave(data)
                    : transformRef.current
                    ? transformRef.current(data)
                    : data
            ).then(data => {
                return create(
                    { payload: { data } },
                    {
                        action: CRUD_CREATE,
                        onSuccess: onSuccessFromSave
                            ? onSuccessFromSave
                            : !!onSuccessRef.current
                            ? onSuccessRef.current
                            : defaultOnSuccess,
                        onFailure: onFailureFromSave
                            ? onFailureFromSave
                            : !!onFailureRef.current
                            ? onFailureRef.current
                            : defaultOnFailure,
                    }
                );
            }),
        [
            create,
            defaultOnFailure,
            defaultOnSuccess,
            onFailureRef,
            onSuccessRef,
            transformRef,
        ]
    );

    const saveContext = {
        save,
        saving,
        setOnSuccess,
        setOnFailure,
        setTransform,
        onSuccessRef,
        onFailureRef,
        transformRef,
    };

    const createContext = useMemo(
        () => ({
            close: hideCreateForm,
        }),
        [hideCreateForm]
    );

    const createFormElement = (
        <SaveContextProvider value={saveContext}>
            <CreateRowContext.Provider value={createContext}>
                {cloneElement(createForm, {
                    classes,
                    expand,
                    hasBulkActions,
                    id: 'new_record',
                    quitEditMode: hideCreateForm,
                    record: {},
                    resource,
                    basePath,
                    save,
                    saving,
                    selectable: false,
                })}
            </CreateRowContext.Provider>
        </SaveContextProvider>
    );
    if (hasStandaloneCreateForm) {
        // create form triggered by state
        return isStandaloneCreateFormVisible && createFormElement;
    }

    // create form in a route
    return <Route path={`${basePath}/create`}>{createFormElement}</Route>;
};

export interface EditableDatagridCreateFormProps {
    basePath?: string;
    classes?: ReturnType<typeof useDatagridStyles>;
    expand?: ReactNode;
    hasBulkActions?: boolean;
    resource?: string;
    createForm?: ReactElement;
    hasStandaloneCreateForm?: boolean;
    isStandaloneCreateFormVisible: boolean;
    closeStandaloneCreateForm: () => void;
}

EditableDatagridCreateForm.propTypes = {
    basePath: PropTypes.string,
    classes: PropTypes.any,
    expand: PropTypes.oneOfType([PropTypes.element, PropTypes.elementType]),
    hasBulkActions: PropTypes.bool.isRequired,
    resource: PropTypes.string,
    createForm: PropTypes.element,
    hasStandaloneCreateForm: PropTypes.bool,
    isStandaloneCreateFormVisible: PropTypes.bool.isRequired,
    closeStandaloneCreateForm: PropTypes.func.isRequired,
};

export default EditableDatagridCreateForm;
