import React from 'react';
import { cleanup, act, fireEvent, waitFor } from '@testing-library/react';
import {
    TextField,
    defaultTheme,
    List,
    ListProps,
    DataProviderContext,
    TextInput,
    required,
} from 'react-admin';
import { renderWithRedux } from 'ra-test';
import { ThemeProvider, createMuiTheme } from '@material-ui/core';
import { Router } from 'react-router-dom';
import { createMemoryHistory } from 'history';

import EditableDatagrid from './EditableDatagrid';
import RowForm, { RowFormProps } from './RowForm';
import { useEditRowContext } from './useEditRowContext';
import { useCreateRowContext } from './useCreateRowContext';

const defaultListProps: ListProps = {
    basePath: '/artists',
    hasCreate: false,
    hasEdit: false,
    hasList: false,
    hasShow: false,
    match: { path: '/artists', params: {}, isExact: false, url: '' },
    resource: 'artists',
};

const defaultStateForList = {
    admin: {
        resources: {
            artists: {
                list: {
                    ids: [],
                    params: {},
                    selectedIds: [],
                    total: 0,
                    cachedRequests: {},
                },
            },
        },
    },
};

const FreePropsWrapper = ({ children }: any) => <span>{children}</span>;

const CreateForm = (props: Omit<RowFormProps, 'children'>) => (
    <RowForm {...props}>
        <FreePropsWrapper>CREATE FORM</FreePropsWrapper>
    </RowForm>
);

const EditForm = (props: Omit<RowFormProps, 'children'>) => (
    <RowForm {...props}>
        <FreePropsWrapper>EDIT FORM</FreePropsWrapper>
    </RowForm>
);

const EditFormWithValidation = (props: Omit<RowFormProps, 'children'>) => (
    <RowForm {...props}>
        <TextInput source="name" validate={required()} />
    </RowForm>
);

describe('EditableDatagrid', () => {
    let dataProvider;

    beforeEach(() => {
        dataProvider = {
            create: jest.fn(() => Promise.resolve({ data: { id: 1 } })),
            delete: jest.fn(() => Promise.resolve({ data: { id: 1 } })),
            deleteMany: jest.fn(() => Promise.resolve({ data: [] })),
            update: jest.fn(() =>
                Promise.resolve({ data: { id: 1, title: 'Foo' } })
            ),
            updateMany: jest.fn(() => Promise.resolve({ data: [], total: 0 })),
            getList: jest.fn(() =>
                Promise.resolve({ data: [{ id: 1, title: 'Foo' }], total: 1 })
            ),
            getMany: jest.fn(() => Promise.resolve({ data: [], total: 0 })),
            getOne: jest.fn(() =>
                Promise.resolve({ data: { id: 1, title: 'Foo' } })
            ),
            getManyReference: jest.fn(() =>
                Promise.resolve({
                    data: [],
                    total: 0,
                })
            ),
        };
    });

    afterEach(cleanup);

    it('should render a datagrid', async () => {
        dataProvider.getList = jest.fn(() =>
            Promise.resolve({
                data: [
                    { id: 1, title: 'Foo' },
                    { id: 2, title: 'Bar' },
                ],
                total: 2,
            })
        );

        const { queryByText, unmount } = renderWithRedux(
            <ThemeProvider theme={createMuiTheme(defaultTheme)}>
                <DataProviderContext.Provider value={dataProvider}>
                    <List
                        {...defaultListProps}
                        hasCreate
                        sort={{ field: 'id', order: 'DESC' }}
                    >
                        <EditableDatagrid
                            undoable
                            createForm={<CreateForm />}
                            editForm={<EditForm />}
                            rowClick="edit"
                        >
                            <TextField source="title" />
                        </EditableDatagrid>
                    </List>
                </DataProviderContext.Provider>
            </ThemeProvider>,
            defaultStateForList
        );

        await new Promise(resolve => setTimeout(resolve));

        expect(queryByText('Foo')).not.toBeNull();
        expect(queryByText('Bar')).not.toBeNull();

        // For some reason, the react tree is not cleaned up up before running subsequent tests
        // This ensure it does not interfere with them
        unmount();
    });

    it('should display an edit form on datagrid row click', async () => {
        dataProvider.getList = jest.fn(() =>
            Promise.resolve({
                data: [{ id: 1, title: 'Baz' }],
                total: 1,
            })
        );

        const { queryByText, unmount } = renderWithRedux(
            <ThemeProvider theme={createMuiTheme(defaultTheme)}>
                <DataProviderContext.Provider value={dataProvider}>
                    <List
                        {...defaultListProps}
                        hasCreate
                        sort={{ field: 'id', order: 'DESC' }}
                    >
                        <EditableDatagrid
                            undoable
                            createForm={<CreateForm />}
                            editForm={<EditForm />}
                            rowClick="edit"
                        >
                            <TextField source="title" />
                        </EditableDatagrid>
                    </List>
                </DataProviderContext.Provider>
            </ThemeProvider>,
            defaultStateForList
        );

        await new Promise(resolve => setTimeout(resolve));

        expect(queryByText('Baz')).not.toBeNull();
        expect(queryByText('EDIT FORM')).toBeNull();

        act(() => {
            fireEvent.click(queryByText('Baz'));
        });

        expect(queryByText('EDIT FORM')).not.toBeNull();
        expect(queryByText('Baz')).toBeNull();

        // For some reason, the react tree is not cleaned up up before running subsequent tests
        // This ensure it does not interfere with them
        unmount();
    });

    it('should submit the form and quit edit mode when the enter key is pressed and the form is valid', async () => {
        dataProvider.getList = jest.fn(() =>
            Promise.resolve({
                data: [{ id: 1, title: 'Baz' }],
                total: 1,
            })
        );

        const { queryByText, queryByLabelText, unmount } = renderWithRedux(
            <ThemeProvider theme={createMuiTheme(defaultTheme)}>
                <DataProviderContext.Provider value={dataProvider}>
                    <List
                        {...defaultListProps}
                        sort={{ field: 'id', order: 'DESC' }}
                    >
                        <EditableDatagrid
                            editForm={<EditFormWithValidation />}
                            rowClick="edit"
                        >
                            <TextField source="title" />
                        </EditableDatagrid>
                    </List>
                </DataProviderContext.Provider>
            </ThemeProvider>,
            defaultStateForList
        );

        await new Promise(resolve => setTimeout(resolve));

        act(() => {
            fireEvent.click(queryByText('Baz'));
        });

        const input = queryByLabelText('resources.artists.fields.name *');
        act(() => {
            fireEvent.change(input, { target: { value: '' } });
            fireEvent.keyDown(input, { key: 'Enter' });
        });

        expect(queryByText('ra.validation.required')).not.toBeNull();
        // Shouldn't have quit the edit mode
        expect(
            queryByLabelText('resources.artists.fields.name *')
        ).not.toBeNull();
        act(() => {
            fireEvent.change(input, { target: { value: 'Bazinga' } });
            fireEvent.keyDown(input, { key: 'Enter' });
        });

        await waitFor(() => {
            expect(queryByText('ra.validation.required')).toBeNull();
        });
        // Should have quit the edit mode
        expect(queryByLabelText('resources.artists.fields.name *')).toBeNull();

        // For some reason, the react tree is not cleaned up up before running subsequent tests
        // This ensure it does not interfere with them
        unmount();
    });

    it('should accept custom side effects for the edit form', async () => {
        dataProvider.getList = jest.fn(() =>
            Promise.resolve({
                data: [{ id: 1, title: 'Baz' }],
                total: 1,
            })
        );
        dataProvider.update = jest
            .fn()
            .mockResolvedValueOnce({ data: { id: 1, title: 'Baz' } })
            .mockRejectedValueOnce('Ouch');

        const onSuccess = jest.fn();
        const onFailure = jest.fn();
        const EditForm = (props: Omit<RowFormProps, 'children'>) => {
            const { close } = useEditRowContext();

            return (
                <RowForm
                    {...props}
                    onSuccess={() => {
                        onSuccess();
                        close();
                    }}
                    onFailure={() => {
                        onFailure();
                        close();
                    }}
                >
                    <FreePropsWrapper>EDIT FORM</FreePropsWrapper>
                </RowForm>
            );
        };

        const history = createMemoryHistory();
        const { getByLabelText, queryByLabelText, queryByText, unmount } =
            renderWithRedux(
                <ThemeProvider theme={createMuiTheme(defaultTheme)}>
                    <DataProviderContext.Provider value={dataProvider}>
                        <Router history={history}>
                            <List
                                {...defaultListProps}
                                hasCreate
                                sort={{ field: 'id', order: 'DESC' }}
                            >
                                <EditableDatagrid
                                    createForm={<CreateForm />}
                                    editForm={<EditForm />}
                                    rowClick="edit"
                                >
                                    <TextField source="title" />
                                </EditableDatagrid>
                            </List>
                        </Router>
                    </DataProviderContext.Provider>
                </ThemeProvider>,
                defaultStateForList
            );

        await new Promise(resolve => setTimeout(resolve));

        act(() => {
            fireEvent.click(queryByText('Baz'));
        });

        fireEvent.click(getByLabelText('ra.action.save'));

        await waitFor(() => {
            expect(onSuccess).toHaveBeenCalled();
            expect(queryByLabelText('ra.action.save')).toBeNull();
        });

        act(() => {
            fireEvent.click(queryByText('Baz'));
        });

        await waitFor(() => {
            getByLabelText('ra.action.save');
        });

        fireEvent.click(getByLabelText('ra.action.save'));

        await waitFor(() => {
            expect(onFailure).toHaveBeenCalled();
        });
        // For some reason, the react tree is not cleaned up up before running subsequent tests
        // This ensure it does not interfere with them
        unmount();
    });

    it('should display a create form on datagrid create button click', async () => {
        dataProvider.getList = jest.fn(() =>
            Promise.resolve({
                data: [{ id: 1, title: 'Baz' }],
                total: 1,
            })
        );

        const history = createMemoryHistory();
        const { queryByText, getByLabelText, unmount } = renderWithRedux(
            <ThemeProvider theme={createMuiTheme(defaultTheme)}>
                <DataProviderContext.Provider value={dataProvider}>
                    <Router history={history}>
                        <List
                            {...defaultListProps}
                            hasCreate
                            sort={{ field: 'id', order: 'DESC' }}
                        >
                            <EditableDatagrid
                                undoable
                                createForm={<CreateForm />}
                                editForm={<EditForm />}
                                rowClick="edit"
                            >
                                <TextField source="title" />
                            </EditableDatagrid>
                        </List>
                    </Router>
                </DataProviderContext.Provider>
            </ThemeProvider>,
            defaultStateForList
        );

        await new Promise(resolve => setTimeout(resolve));

        expect(queryByText('Baz')).not.toBeNull();
        expect(queryByText('CREATE FORM')).toBeNull();

        act(() => {
            fireEvent.click(getByLabelText('ra.action.create'));
        });

        expect(queryByText('CREATE FORM')).not.toBeNull();
        expect(queryByText('Baz')).not.toBeNull();

        // For some reason, the react tree is not cleaned up up before running subsequent tests
        // This ensure it does not interfere with them
        unmount();
    });

    it('should accept custom side effects for the create form', async () => {
        dataProvider.getList = jest.fn(() =>
            Promise.resolve({
                data: [{ id: 1, title: 'Baz' }],
                total: 1,
            })
        );
        dataProvider.create = jest
            .fn()
            .mockResolvedValueOnce({ data: { id: 1 } })
            .mockRejectedValueOnce('Ouch');

        const onSuccess = jest.fn();
        const onFailure = jest.fn();
        const CreateForm = (props: Omit<RowFormProps, 'children'>) => {
            const { close } = useCreateRowContext();

            return (
                <RowForm
                    {...props}
                    onSuccess={() => {
                        onSuccess();
                        close();
                    }}
                    onFailure={() => {
                        onFailure();
                        close();
                    }}
                >
                    <FreePropsWrapper>CREATE FORM</FreePropsWrapper>
                </RowForm>
            );
        };

        const history = createMemoryHistory();
        const { getByLabelText, unmount } = renderWithRedux(
            <ThemeProvider theme={createMuiTheme(defaultTheme)}>
                <DataProviderContext.Provider value={dataProvider}>
                    <Router history={history}>
                        <List
                            {...defaultListProps}
                            hasCreate
                            sort={{ field: 'id', order: 'DESC' }}
                        >
                            <EditableDatagrid
                                undoable
                                createForm={<CreateForm />}
                                editForm={<EditForm />}
                                rowClick="edit"
                            >
                                <TextField source="title" />
                            </EditableDatagrid>
                        </List>
                    </Router>
                </DataProviderContext.Provider>
            </ThemeProvider>,
            defaultStateForList
        );

        await new Promise(resolve => setTimeout(resolve));

        act(() => {
            fireEvent.click(getByLabelText('ra.action.create'));
        });

        fireEvent.click(getByLabelText('ra.action.save'));

        await waitFor(() => {
            expect(onSuccess).toHaveBeenCalled();
        });

        act(() => {
            fireEvent.click(getByLabelText('ra.action.create'));
        });

        await waitFor(() => {
            getByLabelText('ra.action.save');
        });

        fireEvent.click(getByLabelText('ra.action.save'));

        await waitFor(() => {
            expect(onFailure).toHaveBeenCalled();
        });
        // For some reason, the react tree is not cleaned up up before running subsequent tests
        // This ensure it does not interfere with them
        unmount();
    });

    it('should still display a list when page is empty and empty prop is false', async () => {
        dataProvider.getList = jest.fn(() =>
            Promise.resolve({
                data: [],
                total: 0,
            })
        );

        const { queryByText, unmount } = renderWithRedux(
            <ThemeProvider theme={createMuiTheme(defaultTheme)}>
                <DataProviderContext.Provider value={dataProvider}>
                    <List
                        {...defaultListProps}
                        hasCreate
                        sort={{ field: 'id', order: 'DESC' }}
                        empty={false}
                    >
                        <EditableDatagrid
                            undoable
                            createForm={<CreateForm />}
                            editForm={<EditForm />}
                            rowClick="edit"
                        >
                            <TextField source="title" />
                        </EditableDatagrid>
                    </List>
                </DataProviderContext.Provider>
            </ThemeProvider>,
            defaultStateForList
        );

        expect(queryByText('ra.action.create')).not.toBeNull();

        // For some reason, the react tree is not cleaned up up before running subsequent tests
        // This ensure it does not interfere with them
        unmount();
    });
});
