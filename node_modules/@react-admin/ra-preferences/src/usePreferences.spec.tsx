import React, { FC } from 'react';
import { cleanup, fireEvent, waitFor } from '@testing-library/react';
import { DataProviderContext } from 'ra-core';

import { PreferencesSetter, Preferences } from './PreferencesSetter';
import { PreferencesContextProvider } from './PreferencesContextProvider';
import { usePreferences } from './usePreferences';
import { RA_PREFERENCE_WORKSPACE } from './constants';
import { renderWithRedux } from 'ra-test';

describe('usePreferences', () => {
    afterEach(() => {
        cleanup();
        window.localStorage.removeItem(RA_PREFERENCE_WORKSPACE);
    });

    it('should allow to read a preference by path', () => {
        const ComponentToTest: FC = () => {
            const [preferences] = usePreferences('foo') as any;
            return <div>pref:{preferences}</div>;
        };
        const { queryByText } = renderWithRedux(
            <PreferencesSetter path="foo" value="bar">
                <ComponentToTest />
            </PreferencesSetter>
        );
        expect(queryByText('pref:bar')).not.toBeNull();
    });

    it('should allow to read all preferences when called without a path', () => {
        const ComponentToTest: FC = () => {
            const [preferences] = usePreferences() as any;
            return <div>pref:{preferences.foo}</div>;
        };

        const { queryByText } = renderWithRedux(
            <PreferencesSetter path="" value={{ foo: 'bar' }}>
                <ComponentToTest />
            </PreferencesSetter>
        );

        expect(queryByText('pref:bar')).not.toBeNull();
    });

    it('should allow to set a preference by path', () => {
        const ComponentToTest: FC = () => {
            const [preferences] = usePreferences('foo') as any;
            return <div>pref:{preferences}</div>;
        };

        const PreferenceChanger: FC = () => {
            const [_, setPreferences] = usePreferences('foo') as any;
            return (
                <button onClick={(): void => setPreferences('baz')}>
                    click me
                </button>
            );
        };

        const { queryByText } = renderWithRedux(
            <PreferencesSetter path="foo" value="bar">
                <>
                    <ComponentToTest />
                    <PreferenceChanger />
                </>
            </PreferencesSetter>
        );

        expect(queryByText('pref:bar')).not.toBeNull();
        fireEvent.click(queryByText('click me'));
        expect(queryByText('pref:baz')).not.toBeNull();
    });

    it('should allow to set a falsy preference by path', () => {
        const ComponentToTest: FC = () => {
            const [preferences] = usePreferences('foo') as any;
            return <div>pref:{preferences.toString()}</div>;
        };

        const PreferenceChanger: FC = () => {
            const [_, setPreferences] = usePreferences('foo') as any;
            return (
                <button onClick={(): void => setPreferences(false)}>
                    click me
                </button>
            );
        };

        const { queryByText } = renderWithRedux(
            <PreferencesSetter path="foo" value="bar">
                <>
                    <ComponentToTest />
                    <PreferenceChanger />
                </>
            </PreferencesSetter>
        );

        expect(queryByText('pref:bar')).not.toBeNull();
        fireEvent.click(queryByText('click me'));
        expect(queryByText('pref:false')).not.toBeNull();
    });

    it('should allow to set an undefined preference by path', () => {
        const ComponentToTest: FC = () => {
            const [preferences] = usePreferences('foo') as any;
            return (
                <div>
                    pref:
                    {typeof preferences === 'undefined'
                        ? 'undefined'
                        : preferences.toString()}
                </div>
            );
        };

        const PreferenceChanger: FC = () => {
            const [_, setPreferences] = usePreferences('foo') as any;
            return (
                <button onClick={(): void => setPreferences(undefined)}>
                    click me
                </button>
            );
        };

        const { queryByText } = renderWithRedux(
            <PreferencesSetter path="foo" value="bar">
                <>
                    <ComponentToTest />
                    <PreferenceChanger />
                </>
            </PreferencesSetter>
        );

        expect(queryByText('pref:bar')).not.toBeNull();
        fireEvent.click(queryByText('click me'));
        expect(queryByText('pref:undefined')).not.toBeNull();
    });

    it('should allow to set all preferences when called without a path', () => {
        const ComponentToTest: FC = () => {
            const [preferences] = usePreferences('foo') as any;
            return <div>pref:{preferences}</div>;
        };

        const PreferenceChanger: FC = () => {
            const [_, setPreferences] = usePreferences() as any;
            return (
                <button onClick={(): void => setPreferences({ foo: 'bazz' })}>
                    click me
                </button>
            );
        };

        const { queryByText } = renderWithRedux(
            <PreferencesSetter path="foo" value="bar">
                <>
                    <ComponentToTest />
                    <PreferenceChanger />
                </>
            </PreferencesSetter>
        );

        expect(queryByText('pref:bar')).not.toBeNull();
        fireEvent.click(queryByText('click me'));
        expect(queryByText('pref:bazz')).not.toBeNull();
    });

    it('should work with a path that does not point to a direct value', () => {
        const ComponentToTest: FC = () => {
            const [preferences] = usePreferences('foo') as any;
            return <div>pref:{preferences.bar}</div>;
        };

        const { queryByText } = renderWithRedux(
            <PreferencesSetter path="foo.bar" value="baz">
                <ComponentToTest />
            </PreferencesSetter>
        );

        expect(queryByText('pref:baz')).not.toBeNull();
    });

    it('should work with a complex path', () => {
        const ComponentToTest: FC = () => {
            const [preferences] = usePreferences('foo.bar') as any;
            return <div>pref:{preferences}</div>;
        };

        const { queryByText } = renderWithRedux(
            <PreferencesSetter path="foo.bar" value="coucou">
                <ComponentToTest />
            </PreferencesSetter>
        );

        expect(queryByText('pref:coucou')).not.toBeNull();
    });

    it('should return the default value', () => {
        const ComponentToTest: FC = () => {
            const [preferences] = usePreferences('foo', 'hello') as any;
            return <div>pref:{preferences}</div>;
        };

        const { queryByText } = renderWithRedux(
            <PreferencesSetter path="toto" value="titi">
                <ComponentToTest />
            </PreferencesSetter>
        );

        expect(queryByText('pref:hello')).not.toBeNull();
    });

    it('should allow to change back to the default value', () => {
        const ComponentToTest: FC = () => {
            const [preferences, setPreferences] = usePreferences(
                'foo',
                'hello'
            ) as any;
            const handleChangeClick = () => {
                setPreferences('bye');
            };
            const handleBackClick = () => {
                setPreferences('hello');
            };
            return (
                <>
                    <div>pref:{preferences}</div>
                    <button onClick={handleChangeClick}>change</button>
                    <button onClick={handleBackClick}>back</button>
                </>
            );
        };

        const { getByText, queryByText } = renderWithRedux(
            <PreferencesSetter path="toto" value="titi">
                <ComponentToTest />
            </PreferencesSetter>
        );

        expect(queryByText('pref:hello')).not.toBeNull();
        expect(queryByText('pref:bye')).toBeNull();
        fireEvent.click(getByText('change'));
        expect(queryByText('pref:hello')).toBeNull();
        expect(queryByText('pref:bye')).not.toBeNull();
        fireEvent.click(getByText('back'));
        expect(queryByText('pref:bye')).toBeNull();
        expect(queryByText('pref:hello')).not.toBeNull();
    });

    it('should return undefined for non existing path', () => {
        let value;
        const ComponentToTest: FC = () => {
            const [preferences] = usePreferences('foo') as any;
            value = preferences;
            return <div />;
        };

        renderWithRedux(<ComponentToTest />);

        expect(value).toBeUndefined();
    });

    it('should initialize preferences with localStorage', () => {
        window.localStorage.setItem(
            RA_PREFERENCE_WORKSPACE,
            JSON.stringify({ foo: 'bar' })
        );

        const ComponentToTest: FC = () => {
            const [preferences] = usePreferences('foo') as any;
            return <div>pref:{preferences}</div>;
        };

        const { queryByText } = renderWithRedux(<ComponentToTest />);

        expect(queryByText('pref:bar')).not.toBeNull();
    });

    it('should store preferences in localStorage', () => {
        const PreferenceChanger: FC = () => {
            const [_, setPreferences] = usePreferences('foo') as any;
            return (
                <button onClick={(): void => setPreferences('covfefe')}>
                    click me
                </button>
            );
        };

        const { queryByText } = renderWithRedux(
            <PreferencesSetter path="foo" value="coucou">
                <PreferenceChanger />
            </PreferencesSetter>
        );

        const getPreferencesFromLocalStorage = (): Preferences =>
            JSON.parse(window.localStorage.getItem(RA_PREFERENCE_WORKSPACE));

        const initialStoredPreferences = getPreferencesFromLocalStorage();
        expect(initialStoredPreferences.foo).toEqual('coucou');

        fireEvent.click(queryByText('click me'));

        const storedPreferences = getPreferencesFromLocalStorage();
        expect(storedPreferences.foo).toEqual('covfefe');
    });

    it('should synchronize preferences changed from another browser tab', async () => {
        const Preference = () => {
            const [value] = usePreferences('foo') as any;
            return <span>{value}</span>;
        };
        const { queryByText } = renderWithRedux(
            <PreferencesSetter path="foo" value="coucou">
                <Preference />
            </PreferencesSetter>
        );

        expect(queryByText('coucou')).not.toBeNull();

        global.window.dispatchEvent(
            new StorageEvent('storage', {
                key: RA_PREFERENCE_WORKSPACE,
                newValue: '{"foo":"covfefe"}',
            })
        );

        await waitFor(() => {
            expect(queryByText('covfefe')).not.toBeNull();
        });
    });

    it('should synchronize preferences with the dataProvider on first load then on subsequent writes', async () => {
        const PreferenceChanger: FC = () => {
            const [_, setPreferences] = usePreferences('foo', 'coucou') as any;
            return (
                <button onClick={(): void => setPreferences('covfefe')}>
                    click me
                </button>
            );
        };

        const dataProvider = {
            getPreferences: jest
                .fn()
                .mockResolvedValue({ data: { foo: 'fromDataProvider' } }),
            setPreferences: jest.fn().mockResolvedValue({ data: {} }),
        };

        const { queryByText } = renderWithRedux(
            // @ts-ignore
            <DataProviderContext.Provider value={dataProvider}>
                <PreferencesContextProvider synchronize>
                    <PreferenceChanger />
                </PreferencesContextProvider>
            </DataProviderContext.Provider>
        );

        const getPreferencesFromLocalStorage = (): Preferences =>
            JSON.parse(window.localStorage.getItem(RA_PREFERENCE_WORKSPACE));

        const initialStoredPreferences = getPreferencesFromLocalStorage();
        expect(initialStoredPreferences.foo).toEqual('coucou');

        await waitFor(() => {
            const initialStoredPreferences = getPreferencesFromLocalStorage();
            expect(initialStoredPreferences.foo).toEqual('fromDataProvider');
        });
        fireEvent.click(queryByText('click me'));

        const storedPreferences = getPreferencesFromLocalStorage();
        expect(storedPreferences.foo).toEqual('covfefe');
        expect(dataProvider.setPreferences).toHaveBeenCalledWith({
            data: { foo: 'covfefe' },
            previousData: { foo: 'fromDataProvider' },
        });
    });
});
