// Part of this code comes from rehooks useLocalStorage
// (https://github.com/rehooks/local-storage/blob/master/src/use-localstorage.ts)
// We needed to reimplement it, because we don't want the hook to rerender
// the component subscribe to preference "density" when another component
// sets any other preference

import { useEffect, useState, useCallback } from 'react';
import get from 'lodash/get';
import { usePreferencesContext } from './usePreferencesContext';
import { RA_PREFERENCE_WORKSPACE } from './constants';
import {
    getPreferencesStorage,
    KeyValuePair,
    PreferencesChanged,
    readStorage,
    writeStorage,
} from './preferencesStorage';

/**
 * useState-like hook with localStorage persistence. Syncs changes between tabs.
 *
 * Preferences are stored in a tree structure, to allow retrievalm of the complete
 * preferencs list and namespacing.
 *
 * @param {string} path Name of the preference. Separate with dots to namespace, e.g. 'posts.list.columns'. Leave empty to retrieve the entire preference tree.
 * @param {any} defaultValue Default value
 *
 * @return {Object} A value and a setter for the value, in an array - just like for useState()
 *
 * Depending on the argument passed to usePreferences(), the return tuple concerns
 * either a single value, or the whole preference tree.
 *
 * @example // Here is how to **read a single value** from the preference store, with a default value
 *
 * import { usePreferences } from '@react-admin/ra-preferences';
 *
 * const PostList = props => {
 *     const [density] = usePreferences(
 *         'posts.list.density',
 *         'small'
 *     );
 *
 *     return (
 *         <List {...props}>
 *             <Datagrid size={density}>
 *                 ...
 *             </Datagrid>
 *         </List>
 *     );
 * }
 *
 * @example // To **write a single value** use the second return value:
 *
 * const ChangeDensity: FC<any> = () => {
 *     const [density, setDensity] = usePreferences(
 *         'posts.list.density',
 *         'small'
 *     );
 *
 *     const changeDensity = (): void => {
 *         setDensity(density === 'small' ? 'medium' : 'small');
 *     };
 *
 *     return (
 *         <Button onClick={changeDensity}>
 *             {`Change density (current ${density})`}
 *         </Button>
 *     );
 * };
 *
 * @example // To **read and write the entire preferences tree**, don't pass any argument to the hook. You will find this option useful when building a preferences Form:
 *
 * import { usePreferences } from '@react-admin/ra-preferences';
 * import { useNotify } from 'react-admin';
 * import { Form, Field } from 'react-final-form'
 *
 * const PreferencesPane = () => {
 *     const [preferences, setPreferences] = usePreferences();
 *     const notify = useNotify();
 *
 *     const handleSave = values => {
 *         setPreferences(values);
 *         notify('preferences saved');
 *     }
 *
 *     return (
 *         <Form
 *             initialValues={preferences}
 *             onSubmit={handleSave}
 *             render={({ handleSubmit }) => (
 *                 <form onSubmit={handleSubmit}>
 *                     <div>
 *                         <label>Post list density</label>
 *                         <Field name="posts.list.density" component="select">
 *                             <option value="small">Small</option>
 *                             <option value="medium">Medium</option>
 *                         </Field>
 *                     </div>
 *                     <button type="submit">Submit</button>
 *                 </form>
 *             )}
 *         />
 *     );
 * }
 *
 * **Tip**: The preferences API is synchronous, because preferences are stored in memory, and replicated in localStorage. So even though localStorage has an async API, the preferences API is synchronous.
 */
export const usePreferences = <T = any>(
    key = '',
    defaultValue?: T
): [T, (value: T) => void] => {
    const [localState, updateLocalState] = useState<T>(() => {
        const storedValue = readStorage<T>(key);
        return typeof storedValue === 'undefined' ? defaultValue : storedValue;
    });
    const preferencesContext = usePreferencesContext();

    const onPreferencesChange = (
        event: CustomEvent<KeyValuePair<string, T>>
    ): void => {
        // preference events are custom events we send when modifying  preferences
        // from the same tabs (because local storage events won't fire in the same tab)

        // custom events payload contain full preferences, so we get the value we're
        // subscribed to from the new preferences
        const newValue = get(event.detail, key /* my own key */);
        // and we update our state no matter what. If same value, it won't redraw anyway
        updateLocalState(newValue);
    };

    const onLocalStorageChange = (event: StorageEvent): void => {
        if (event.key !== RA_PREFERENCE_WORKSPACE) {
            return;
        }
        // localStorage events send the full localstorage value (ie. full preferences)
        // there's a chance we're concerned or not by the event
        // so we get the value we're subscribed to from the new preferences
        const preferences = JSON.parse(event.newValue);
        const newValue = get(preferences, key /* my own key */);
        // and we update our state no matter what. If same value, it won't redraw anyway
        updateLocalState(newValue);
    };

    // when the key changes, update localState to reflect it.
    useEffect(() => {
        const storedValue = readStorage<T>(key);
        updateLocalState(
            typeof storedValue === 'undefined' ? defaultValue : storedValue
        );
    }, [key]); // eslint-disable-line react-hooks/exhaustive-deps

    useEffect(() => {
        // the custom storage event allows us to update our component
        // when a change occurs in localStorage outside of our component (same browser tab)
        window.addEventListener(
            PreferencesChanged.eventName,
            onPreferencesChange
        );

        // the storage event only works in the context of other documents (eg. other browser tabs)
        window.addEventListener('storage', onLocalStorageChange);

        const canWrite =
            getPreferencesStorage().getItem(RA_PREFERENCE_WORKSPACE) === null;

        // write initial value to the local storage if it's not present or contains invalid JSON data.
        if (defaultValue !== undefined && canWrite) {
            writeStorage<T>(key, defaultValue);
        }

        return (): void => {
            window.removeEventListener(
                PreferencesChanged.eventName,
                onPreferencesChange
            );
            window.removeEventListener('storage', onLocalStorageChange);
        };
    }, [key]); // eslint-disable-line react-hooks/exhaustive-deps

    const writeState = useCallback(
        (value: T) => {
            const previousData = readStorage();
            const data = writeStorage<T>(key, value);

            // PreferencesContext is optional
            if (preferencesContext) {
                preferencesContext.updatePreferences(data, previousData);
            }
        },
        [key, preferencesContext]
    );

    return [localState === undefined ? defaultValue : localState, writeState];
};
