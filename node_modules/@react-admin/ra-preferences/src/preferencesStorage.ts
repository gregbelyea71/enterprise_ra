import set from 'lodash/set';
import get from 'lodash/get';
import { RA_PREFERENCE_WORKSPACE } from './constants';

export const getPreferencesStorage = () => {
    if (localStorageAvailable == undefined) {
        localStorageAvailable = testLocalStorage();
    }

    return localStorageAvailable ? window.localStorage : memoryStorage;
};

/**
 * reads key preference from storage
 *
 * @param {string} key Path of the preference key to read, uses lodash.get
 *
 * @return {T} Preference value

 * @example // Read full preferences
 *
 * const preferences = readStorage<PreferenceType>();
 *
 * @example // read preference for a particular key
 *
 * const density = readStorage<string>('density');

 * @example // read preference for a deep key
 *
 * const columns = readStorage<string[]>('orders.list.columns');
 */
export const readStorage = <T>(key?: string): T => {
    const preferences =
        JSON.parse(getPreferencesStorage().getItem(RA_PREFERENCE_WORKSPACE)) ||
        {};
    if (key) {
        return tryParse(get(preferences, key)) as T;
    }
    return (tryParse(preferences) || {}) as T;
};

/**
 * sets key preference to value on the preference storage
 *
 * @param {string} key Path of the preference key to update, uses lodash.set
 * @param {T} value New preference value
 *
 * @return {void}
 *
 * @example // Write full preferences to localstorage
 *
 * writeStorage<PreferenceType>('', {
 *      users: {
 *          lists: {
 *              columns: ['id', 'address'],
 *          },
 *      },
 *  });
 *
 * @example // Update preference for a particular key
 *
 * writeStorage<string>('density', 'small');
 *
 * @example // Update preference for a deep key
 *
 * writeStorage<string[]>('orders.list.columns', ['id', 'date', 'customer']);
 */
export const writeStorage = <T>(key: any, value?: T): any => {
    const storage = getPreferencesStorage();

    try {
        const preferences =
            JSON.parse(storage.getItem(RA_PREFERENCE_WORKSPACE)) || {};

        const newPreferences =
            key === '' ? value : set({ ...preferences }, key, value);

        storage.setItem(
            RA_PREFERENCE_WORKSPACE,
            JSON.stringify(newPreferences)
        );
        window.dispatchEvent(PreferencesChanged.create<T>(newPreferences));

        return newPreferences;
    } catch (err) {
        if (
            err instanceof TypeError &&
            err.message.includes('circular structure')
        ) {
            throw new TypeError(
                'The object that was given to the writeStorage function has circular references.\n' +
                    'For more information, check here: ' +
                    'https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Cyclic_object_value'
            );
        }
        throw err;
    }
};

export const overwriteStorage = (value: any): void => {
    const storage = getPreferencesStorage();
    storage.setItem(RA_PREFERENCE_WORKSPACE, JSON.stringify(value));
};

let localStorageAvailable = undefined;
const storage = {};
const memoryStorage = {
    getItem(key: string): string {
        return get(storage, key);
    },
    setItem(key: string, value: string): void {
        set(storage, key, value);
    },
};

const tryParse = (value: string): any => {
    try {
        return JSON.parse(value);
    } catch {
        return value;
    }
};

const testLocalStorage = () => {
    if (window.localStorage == undefined) {
        return false;
    }

    try {
        window.localStorage.setItem('test', 'test');
        window.localStorage.removeItem('test');
        return true;
    } catch {
        return false;
    }
};

export interface KeyValuePair<K, V> {
    key: K;
    value: V;
}

export const PreferencesChanged = {
    eventName: 'onPreferencesChange',
    create: <T>(
        payload: KeyValuePair<string, T>
    ): CustomEvent<KeyValuePair<string, T>> =>
        new CustomEvent<KeyValuePair<string, T>>(PreferencesChanged.eventName, {
            detail: payload,
        }),
};
